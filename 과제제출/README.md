# 스프링 완전 정복

## 01. 스프링 입문

### ❔[1. ](#❕1)
### ❔[2. ](#❕2)
### ❔[3. ](#)
### ❔[4. ](#)
### ❔[5. ](#)
### ❔[6. ](#)

---
## 모범답안

### ❕싱글톤 패턴 개념과 구현 방법에 대해 설명하시오.

<details> <summary>1. 모범답안</summary> <div markdown="1">  


  ```
  싱글톤 패턴은 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴으로, 한 번 생성된 객체를 어디에서든지 참조할 수 있도록 한다.
  가장 단순한 구현 방식으로는 먼저 static 영역에 싱글톤 객체 instance 를 하나 생성해서 올려둔다. 
  이 때 객체에 대한 직접 접근을 막기 위해 private 으로 선언하며, 
  동일한 인스턴스를 2개 이상 생성하지 못하도록 생성자 또한 private 으로 선언한다. 
  그리고 해당 인스턴스를 반환하는 static 메소드 getInstance() 만을 사용해서 싱글톤 객체를 가져올 수 있도록 한다.
  ```

  ##### 해설
  위 답변은 강의에서 가장 단순하게 구현한 방법을 토대로 설명한 것인데, 다음과 같은 구현 방식도 많이 사용한다.
  인스턴스를 미리 만들지 않고 필요할 때 생성하도록 만드는 방법으로, getInstance() 로 인스턴스를 가져오려고 할 때 
  인스턴스 객체가 생성되어 있지 않으면(null) 그 때 인스턴스 객체를 생성하고, 이미 존재하는 경우에는 생성되어있는 객체를 리턴하는 방식이다.

  class Singleton {
    private static Singleton instance = null;

    public static Singleton getInstance() {

        if (instance == null) {
            instance = new Singleton();
        }

        return instance;
    }

    private Singleton() {}
  }
</div> </details>


<details> <summary>1-1. 싱글톤 패턴의 문제점과 스프링 싱글톤 레지스트리를 연관지어 설명하시오.</summary> <div markdown="1">  


  ```
  싱글톤 패턴은 구현 코드 자체도 많이 들어가고, 클라이언트가 구체 클래스에 의존하는 특성 상 DIP나 OCP와 같은 객체지향 원칙을 위배할 수 있다.
  그리고 private 생성자를 갖고 있어 객체 지향의 장점인 상속과 다형성 적용이 불가하다.
  이외에도 만들어지는 방식이 제한적이어서 테스트하기가 어려워 안티 패턴이라고도 한다.

  그러나 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 객체 인스턴스를 싱글톤으로 관리하는데 이 기능을 싱글톤 레지스트리라고 한다. 
  이렇게 객체 생성을 스프링에 위임함으로써, 앞서 언급한 자바 언어 레벨에서 직접 구현하면서 생기는 단점들이 모두 제거된다.
  ```

  ##### 해설
  객체지향 원칙을 지키기 위해서는 인터페이스로 설계하는 것이 좋은 설계이다.
  그러나 싱글톤을 사용할 때 대부분 인터페이스가 아니라 구현 클래스의 객체를 미리 생성해놓고 정적 메소드를 이용해서 구현하기 때문에 
  객체지향 원칙을 위배하게 된다.(DIP 위반)
  또한 싱글톤 클래스를 사용하는 다른 클래스들은 싱글톤 객체에 직접 의존하게 되어 결합도가 높아져셔(OCP 위반) 수정이나 단위 테스트의 어려움이
  생긴다.
  그 외에도 객체를 private 으로 설정하므로 상속이 불가능하여 다형성같은 객체지향 특징을 적용할 수 없으므로 객체지향의 의도와 맞지 않는다.

  스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 직접 객체 인스턴스를 싱글톤 형태로 관리하는데 이 기능을 싱글톤 레지스트리라고 한다.
  스프링의 이러한 기능 덕에 평범한 객체도 하나의 인스턴스 뿐인 싱글톤으로 존재가 가능하므로,
  싱글톤을 만들기 위해 static 메소드나 private 생성자 등을 이용할 필요가 없다.
  따라서 상속이 가능해지고 객체지향적으로 개발할 수 있으며, 생성자 파라미터를 통해 구현체를 주입받거나 테스트를 할 때에도 
  제약없이 자유롭게 사용할 수 있다.
</div> </details>



<details> <summary>1-2. 싱글톤 패턴은 멀티스레드 환경에서 어떤 문제가 생기는지와 해결 방법에 대해 설명하시오.</summary> <div markdown="1">  


  ```
  여러 개의 스레드가 한 인스턴스에 접근함으로써 동시성 문제가 생길 수 있다.
  여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하므로 무상태로 설계해야 한다. 
  해결 방법으로는 필드 대신에 공유되지 않는 지역 변수나 파라미터, ThreadLocal, Synchronized 등을 사용해야 한다.
  ```

  ##### 해설
  한 인스턴스에서 어떤 필드를 읽는 용도로만 사용되면 문제가 되지 않지만, 스레드는 순차 실행되는 것이 아니므로 쓰는 용도로도 사용하게 된다면
  동시성 문제(동일한 자원에 대해 여러 스레드가 동시에 접근 하면서 발생하는 문제)가 발생하게 된다. 이외에도 싱글톤 패턴으로 생성되는 객체가
  전역변수를 가졌을 때에도 문제가 생긴다.

  먼저 싱글톤 패턴으로 생성되는 객체가 전역변수인 경우, 전역 변수 영역은 JVM의 Heap에 저장됨으로 여러 스레드가 공유되므로 Thread Safe 
  하지 않다. 반면 지역변수 영역은 JVM의 Stack에 저장됨으로 각자의 스레드를 갖고 있어 Thread Safe 하므로, 지역 변수나 파라미터로
  변경해주면 해결이 가능하다.

  ThreadLocal은 간단하게 말하면 스레드 전용 보관소로, 만약 인스턴스의 필드가 ThreadLocal로 이루어져 있다면 임의의 스레드가 해당 필드에
  접근할 때 해당 스레드가 어느 스레드인지 파악을 한다. 그리고 스레드의 전용 필드를 생성하거나 스레드의 전용 필드에 있는 값을 반환해주어 동시성
  문제를 해결할 수 있다. ThreadLocal 을 사용하게 되면 싱글턴 인스턴스의 필드를 모든 스레드가 안전하게 공유를 할 수 있다. (ThreadLocal
  을 사용한 후 필요없어지면 반드시 remove() 를 사용해서 없애주어야 한다.)

  (여러 개의 쓰레드가 동시에 싱글톤 클래스의 getInstance() 에 접근하는 경우) Synchronized 키워드를 사용하여 getInstance() 메소드를
  동기화해주면, 최초로 접근한 스레드가 해당 메소드 호출을 종료할 때까지 다른 스레드가 접근하지 못하도록 lock을 걸어준다.
  다만 getInstance() 를 호출할 때마다 lock 이 걸려 성능 저하가 발생한다는 단점이 있다.

  참고 : https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%8B%B1%EA%B8%80%ED%86%A4Singleton-%ED%8C%A8%ED%84%B4-%EA%BC%BC%EA%BC%BC%ED%95%98%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90


</div> </details>