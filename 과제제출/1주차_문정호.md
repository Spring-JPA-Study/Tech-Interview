# 스프링 완전 정복

## 01. 스프링 입문

### ❔[1. ](#❕1) DI와 IoC 무엇인가?
### ❔[2. ](#❕2) 생성자 주입을 권장하는 이유는?
### ❔[3. ](#)
### ❔[4. ](#)
### ❔[5. ](#)
### ❔[6. ](#)

---
## 모범답안

### ❕[1. ](#❔1) DI와 IoC 무엇인가?

<details> <summary>1. 모범답안</summary> <div markdown="1">  


  ```
  DI는 클래스나 모듈 등의 객체가 다른 객체에 대한 의존성을 직접 생성하거나 해결하지 않고, 외부로부터 의존성을 주입받는 패턴
  필드주입, 수정자주입, 생성자주입의 방법이 있습니다.
  객체 간의 결합도를 낮추고, 유연성을 높일 수 있다.
  
  IoC는 객체의 생성, 생명주기 관리, 의존성 해결 등의 제어를 개발자가 아닌 프레임워크나 컨테이너에 위임하는 패턴
  스프링에서는 IoC컨테이너를 통해 객체를 관리합니다.
  ```

  ##### 해설

    DI(Dependency Injection)은 객체가 다른 객체에 대한 의존성을 직접 생성 또는 해결하지 않고, 외부에서 의존성을 주입받는 패턴입니다. 
    의존성 주입은 필드 주입, 수정자 주입, 생성자 주입 등의 방법을 사용하여 이루어집니다. 
    DI를 통해 객체 간의 결합도를 낮출 수 있고, 유연성을 높일 수 있습니다.
    
    반면에 IoC(Inversion of Control)는 객체의 생성, 생명주기 관리, 의존성 해결 등의 제어를 개발자가 아닌 프레임워크나 컨테이너에 위임하는 패턴입니다. 
    IoC 컨테이너는 객체의 생성과 관리를 담당하며, 객체 간의 의존성을 자동으로 해결합니다. 
    스프링 프레임워크에서는 IoC 컨테이너를 제공하여 객체의 생성과 의존성 주입을 관리합니다.
    
    DI는 IoC를 구현하는 방법 중 하나로, 객체 간의 의존성을 주입하는 방식을 의미합니다.
    IoC는 객체의 제어권을 개발자에서 프레임워크나 컨테이너로 넘기는 개념이며,
    객체의 생성과 의존성 해결을 프레임워크가 담당합니다.






</div> </details>


<details> <summary>1-1. IoC컨테이너의 장점</summary> <div markdown="1">  


  ```
  애플리케이션의 객체(빈)을 IoC 컨테이터가 관리해줌으로써 개발자의 부담이 줄고 비즈니스 로직에 더욱 집중할 수 있다는 장점
  ```

  ##### 해설

    - 객체의 생명주기 관리 :IoC컨테이너는 객체의 생성, 초기화, 소멸 같은 생명주기를 관리한다.
    - 의존성 관리 : IoC 컨테이너는 객체간의 의존성을 자동으로 해결해준다.
    - 객체의 관리와 검색 : IoC 컨테이너는 객체를 관리하고 필요할 때 검색할 수있는 기능을 제공
    - 객체를 관리해주는 프레임워크와 비즈니스 코드의 역할과 관심을 분리해
    응집도를 높이고 결합도를 낮추며, 변경에 유연한 코드를 작성할 수 있는 구조가 될수 있기 때문에
    제어를 역전한 것이다.
    - 유닛테스트 시 장점.

</div> </details>



<details> <summary>1-2. IOC 컨테이너의 핵심적인 클래스는?</summary> <div markdown="1">  


  ```
  BeanFactory, ApplicationContext
  ```

  ##### 해설

    1. 빈 팩토리 BeanFactory (org.springframework.beans.factory.BeanFactory) 

    DI의 기본사항을 제공하는 가장 단순한 컨테이너
    팩토리 디자인 패턴을 구현한 것. Bean(이하 빈) 팩토리는 빈을 생성하고 분배하는 책임을 지는 클래스
    getBean()이 호출되면, 팩토리는 의존성 주입을 이용해 빈을 인스턴스 화하고 빈의 특성을 설정하기 시작

    2. 애플리케이션 콘텍스트 ApplicationContext (org.springframework.context.factory.BeanFactory) 

    빈 팩토리와 유사한 기능을 제공하지만 좀 더 많은 기능을 제공하는 애플리케이션 콘텍스트
    결국 beanfactory를 상속받은 인터페이스, 따라서 ioc 컨테이너로서의 기능과 추가적으로 Environmentcapable, eventpublisher, MessageSource, ResoureLoader 등의 기능을 가진다.
    즉 다양한 기능을 추가적으로 가진 인터페이스

</div> </details>

<br>

### ❕[2. ](#❔2) 생성자 주입을 권장하는 이유는?

<details> <summary>2. 모범답안</summary> <div markdown="1">  


  ```
  명시적인 의존성 표현
  결합도 감소
  불변성 보장
  순환 참조를 컴파일 단계에서 찾아낼 수 있다.
  테스트하기 쉬워짐
  ```

  ##### 해설
    객체를 생성할 때 생성자를 통해 의존성을 주입하는 방식입니다.
    객체 생성 시점에 모든 의존성이 주입되므로, 의존성 누락이나 잘못된 순서로 주입되는 일을 방지할 수 있습니다.
    컴파일 타임에 의존성 주입이 일어나므로 런타임에 NullPointerException과 같은 예외가 발생할 가능성이 줄어듭니다.
    생성자 파라미터를 통해 어떤 의존성이 필요한지 명시적으로 표시되기 때문에 코드 가독성이 좋아집니다.



</div> </details>


<details> <summary>2-1. 순환참조란?</summary> <div markdown="1">  


  ```
  순환참조는 서로 다른 여러 개의 객체가 서로를 참조하고 있는 상황을 말합니다.
  필드주입이나 수정자 주입은 컴파일 단계에서 순환참조의 유무를 판단할 수 없어, 실제 메서드 실행 시점에서 알 수 있으며
  생성자주입을 사용하면 스프링 컨테이너가 빈을 생성하는 시점에 순환 참조 존재 여부를 판단할 수 있다.
  순환참조 발생 시 무한루프 발생, 메모리누수, 객체간 의존성 문제가 발생합니다.

  ```

  ##### 해설
    Field 선언과 Constructor 선언의 차이를 알아야한다.

    Field 선언
    Field 선언 시 Member 클래스가 로드되었을때 Level class 타입의 level reference 변수만 가지고 있다.
    즉, 클래스 A의 객체가 생성되었을때 level을 생성할 필요가 없다.
    
    Constructor 선언
    생성자로써 객체가 생성될때 실행되는 메서드, 객체 A가 생성될때 객체 B를 생성하여 담는다.
    
    따라서 실행 시점에 따라 프레임워크에서 오류를 발견할 수 있는 생성자 주입 방식을 사용하는게 권장된다.

</div> </details>



<details> <summary> 2-2. 스프링에서 ioc 컨테이너가 빈을 관리하는 이유</summary> <div markdown="1">  


  ```
    1. 의존성 주입
    2. 객체의 생명주기관리
    3. AOP 구현
    4. 관리및 제어의 편의성
  ```

  ##### 해설
    의존성 주입을 받으려면 빈이 돼야 한다.  
    사용하는 리소스에 따라 행동을 달리해야 하는 경우 의존성 주입을 사용하는 것이 낫다. 
    ioc 컨테이너에는 빈들간의 의존성 주입을 제공한다.

    어떤 빈이 만들어졌을 때 부가적인 작업을 만들 수 있다.  

    싱글톤으로 객체를 만들어서 관리하고 싶을 때 ioc 컨테이너를 사용하면 편리하다.
    싱글톤: 하나의 객체만 사용
    프로토타입 : 매번 다른 객체를 사용
    메모리면에서도 효율적이고 하나의 객체를 사용하기에 런타임 시 성능 최적화에도 유리



</div> </details>